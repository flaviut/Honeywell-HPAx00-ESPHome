substitutions:
  # https://esphome.io/guides/configuration-types.html#substitutions
  device_name: hepa-filter # hostname & entity_id
  friendly_name: HEPA Filter # Displayed in HA frontend
  filter_life: "1200" #hours
  prefilter_life: "300" #hours
  touch_threshold_timer: "2520"
  touch_threshold_dimmer: "3000"
  touch_threshold_prefilter: "3019"
  touch_threshold_filter: "2376"
  touch_threshold_turbo: "3722"
  touch_threshold_power: "2430"
  touch_setup_mode: "false" # https://esphome.io/components/binary_sensor/esp32_touch/

esphome:
  name: ${device_name}
  name_add_mac_suffix: true
  friendly_name: ${friendly_name}

  on_boot:
    - light.turn_on:
        id: status_light
        effect: "Rainbow Wave"
    - delay: 2s
    - light.turn_off:
        id: status_light
        transition_length: 1s
    - lambda: |-
        // Initialize interaction time so auto-dim kicks in after boot
        id(last_interaction_time) = millis();

esp32:
  board: nodemcu-32s

logger:

# Enable Home Assistant API
api:

# Allow Over-The-Air updates
ota:
  platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

light:
  - platform: neopixelbus
    type: GRB
    variant: WS2811
    pin: GPIO2
    num_leds: 10
    id: status_light
    name: led_strip
    internal: True
    effects:
      - addressable_rainbow:
          name: "Rainbow Wave"
          speed: 10
          width: 50

# LED locations
#0 under power button
#1 check filter
#2 check pre filter
#3 timer "2" bottom
#4 timer  "4" middle
#5 timer "8" top
#6 Fan "Germ" bottom
#7 fan "general clean" middle
#8 fa "allergen" top
#9 turbo

esp32_touch:
  setup_mode: ${touch_setup_mode}
  voltage_attenuation: 1.5V
  iir_filter: 100ms

binary_sensor:
  - platform: esp32_touch
    threshold: ${touch_threshold_timer}
    pin: GPIO12
    id: timer
    on_press:
      then:
        - lambda: |-
            id(last_interaction_time) = millis();
            id(leds_dimmed) = false;
            // Cycle: 0 -> 2 -> 4 -> 8 -> 0
            int current = id(timer_hours);
            if (current == 0) {
              id(timer_hours) = 2;
            } else if (current == 2) {
              id(timer_hours) = 4;
            } else if (current == 4) {
              id(timer_hours) = 8;
            } else {
              id(timer_hours) = 0;
            }
            // Set end time
            if (id(timer_hours) > 0) {
              id(timer_end_time) = millis() + (id(timer_hours) * 3600000UL);
            } else {
              id(timer_end_time) = 0;
            }
  - platform: esp32_touch
    threshold: ${touch_threshold_dimmer}
    pin: GPIO13
    id: dimmer
    on_press:
      then:
        - lambda: |-
            // Cycle through dim levels: 0.35 -> 0.70 -> 1.00 -> 0.00
            float current_level = id(stored_dim_level);
            
            if (current_level < 0.2) { // Was 0.0
               id(stored_dim_level) = 0.35;
            } else if (current_level < 0.5) { // Was 0.35
               id(stored_dim_level) = 0.70;
            } else if (current_level < 0.85) { // Was 0.70
               id(stored_dim_level) = 1.0;
            } else { // Was 1.0
               id(stored_dim_level) = 0.0;
            }
            
            // Force "dimmed" state and show preview immediately
            id(leds_dimmed) = true;
            id(current_brightness) = id(stored_dim_level);
            // Do NOT reset last_interaction_time so it stays in this preview state
  - platform: esp32_touch
    threshold: ${touch_threshold_prefilter}
    pin: GPIO4
    id: prefilter
    on_multi_click:
      - timing:
          - ON for at least 3s
        then:
          - lambda: |-
              id(prefilter_hours) = 0.0;
              id(last_interaction_time) = millis();
              id(leds_dimmed) = false;
    on_press:
      then:
        - lambda: |-
            id(last_interaction_time) = millis();
            id(leds_dimmed) = false;
  - platform: esp32_touch
    threshold: ${touch_threshold_filter}
    pin: GPIO32
    id: filter
    on_multi_click:
      - timing:
          - ON for at least 3s
        then:
          - lambda: |-
              id(filter_hours) = 0.0;
              id(last_interaction_time) = millis();
              id(leds_dimmed) = false;
    on_press:
      then:
        - lambda: |-
            id(last_interaction_time) = millis();
            id(leds_dimmed) = false;
  - platform: esp32_touch
    threshold: ${touch_threshold_turbo}
    pin: GPIO33
    id: turbo
    on_press:
      then:
        - lambda: |-
            id(last_interaction_time) = millis();
            id(leds_dimmed) = false;
        - fan.turn_on:
            id: my_fan
            speed: 4
  - platform: esp32_touch
    threshold: ${touch_threshold_power}
    pin: GPIO27
    id: power
    on_press:
      then:
        - lambda: |-
            id(last_interaction_time) = millis();
            id(leds_dimmed) = false;
        - fan.cycle_speed:
            id: my_fan
            off_speed_cycle: true


switch:
# these are the correct pins for V2 units, V1 units may need to reverse the order of the GPIO pins
# and in fan_low = GPIO21, fan_mid = GPIO25, fan_high = GPIO22, fan_turbo = GPIO17
  - platform: gpio
    pin: GPIO17
    id: fan_low
    interlock_wait_time: 250ms
    interlock: &interlock_group [fan_low, fan_mid, fan_high, fan_turbo]
  - platform: gpio
    pin: GPIO22
    id: fan_mid
    interlock_wait_time: 250ms
    interlock: *interlock_group
  - platform: gpio
    pin: GPIO25
    id: fan_high
    interlock_wait_time: 250ms
    interlock: *interlock_group
  - platform: gpio
    pin: GPIO21
    id: fan_turbo
    interlock_wait_time: 250ms
    interlock: *interlock_group
output:
  - platform: template
    id: fan_speed_output
    type: float
    write_action:
      - lambda: |-
          // Determine new speed factor
          float new_factor = 0.0;
          if (state < 0.24) {
            new_factor = 0.0;
          } else if (state < 0.26) {
            new_factor = 0.25;
          } else if (state < 0.51) {
            new_factor = 0.5;
          } else if (state < 0.76) {
            new_factor = 0.75;
          } else {
            new_factor = 1.0;
          }
          
          // Only trigger interaction/dim reset if speed ACTUALLY changed
          // Using a small epsilon for float comparison just in case, though direct eq is likely fine here
          if (abs(id(current_fan_speed_factor) - new_factor) > 0.01) {
            id(last_interaction_time) = millis();
            id(leds_dimmed) = false;
            
            // Immediate feedback: clear old speed LEDs and set new one
            auto light = ((AddressableLight*)id(status_light).get_output());
            light->get(6).set(Color::BLACK); 
            light->get(7).set(Color::BLACK); 
            light->get(8).set(Color::BLACK); 
            light->get(9).set(Color::BLACK);
            
            if (new_factor > 0.9) { // Turbo
               light->get(9).set(Color(255, 0, 0, 0));
            } else if (new_factor > 0.6) { // High
               light->get(8).set(Color(230, 135, 0, 0));
            } else if (new_factor > 0.4) { // Mid
               light->get(7).set(Color(176, 200, 0, 0));
            } else if (new_factor > 0.1) { // Low
               light->get(6).set(Color(0, 255, 0, 0));
            }
            light->schedule_show();
            
            id(current_fan_speed_factor) = new_factor;
          }
          
          // ALWAYS update relays to match requested state (safety/consistency)
          id(fan_low).turn_off();
          id(fan_mid).turn_off();
          id(fan_high).turn_off();
          id(fan_turbo).turn_off();

          if (new_factor > 0.9) {
            id(fan_turbo).turn_on();
          } else if (new_factor > 0.6) {
            id(fan_high).turn_on();
          } else if (new_factor > 0.4) {
            id(fan_mid).turn_on();
          } else if (new_factor > 0.1) {
            id(fan_low).turn_on();
          }

fan:
  - platform: speed
    name: "Filter Speed"
    output: fan_speed_output
    speed_count: 4
    id: my_fan

number:
  - platform: template
    name: "Filter Lifetime"
    id: filter_life_number
    unit_of_measurement: "h"
    entity_category: config
    min_value: 100
    max_value: 5000
    step: 1
    lambda: |-
      return id(filter_life_hours);
    set_action:
      then:
        - lambda: |-
            id(filter_life_hours) = x;

  - platform: template
    name: "Prefilter Lifetime"
    id: prefilter_life_number
    unit_of_measurement: "h"
    entity_category: config
    min_value: 100
    max_value: 5000
    step: 1
    lambda: |-
      return id(prefilter_life_hours);
    set_action:
      then:
        - lambda: |-
            id(prefilter_life_hours) = x;

globals:
  # Timer state
  - id: timer_hours
    type: int
    restore_value: no
    initial_value: '0'
  - id: timer_end_time
    type: uint32_t
    restore_value: no
    initial_value: '0'
  # Filter tracking (update every 10 min to reduce flash wear)
  - id: filter_hours
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: prefilter_hours
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: current_fan_speed_factor
    type: float
    restore_value: no
    initial_value: '0.0'
  # Auto-dim state
  - id: last_interaction_time
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: leds_dimmed
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: stored_dim_level
    type: float
    restore_value: yes
    initial_value: '0.35'
  - id: current_brightness
    type: float
    restore_value: no
    initial_value: '1.0'
  - id: filter_life_hours
    type: float
    restore_value: yes
    initial_value: ${filter_life}
  - id: prefilter_life_hours
    type: float
    restore_value: yes
    initial_value: ${prefilter_life}

interval:
  # Timer countdown check and LED update (high frequency for fade)
  - interval: 50ms
    then:
      - lambda: |-
          auto light = ((AddressableLight*)id(status_light).get_output());
          
          // --- FADE LOGIC ---
          float target = id(leds_dimmed) ? id(stored_dim_level) : 1.0;
          float current = id(current_brightness);
          
          // 50ms interval. 
          // 3s fade (Dimming) -> 3000ms / 50ms = 60 steps. Delta approx 0.012
          // 0.5s fade (Undimming) -> 500ms / 50ms = 10 steps. Delta approx 0.07
          
          if (current < target) {
             current += 0.07; // Fast fade in
             if (current > target) current = target;
          } else if (current > target) {
             current -= 0.012; // Slow fade out (3s)
             if (current < target) current = target;
          }
          id(current_brightness) = current;
          float dim = current;
          // ------------------
          
          // Clear timer LEDs first
          light->get(3).set(Color::BLACK);
          light->get(4).set(Color::BLACK);
          light->get(5).set(Color::BLACK);
          
          // Clear fan speed LEDs first
          light->get(6).set(Color::BLACK); // Low
          light->get(7).set(Color::BLACK); // Mid
          light->get(8).set(Color::BLACK); // High
          light->get(9).set(Color::BLACK); // Turbo

          if (id(timer_end_time) > 0) {
            uint32_t now = millis();
            if (now >= id(timer_end_time)) {
              // Timer expired - turn off fan
              id(timer_hours) = 0;
              id(timer_end_time) = 0;
              auto call = id(my_fan).turn_off();
              call.perform();
            } else {
              // Calculate remaining hours and show appropriate LED
              uint32_t remaining_ms = id(timer_end_time) - now;
              float remaining_hours = remaining_ms / 3600000.0;
              
              // Light LED based on remaining time
              Color blue = Color(0, 0, (uint8_t)(255 * dim), 0);
              if (remaining_hours > 4) {
                light->get(5).set(blue);  // 8h LED
              } else if (remaining_hours > 2) {
                light->get(4).set(blue);  // 4h LED
              } else if (remaining_hours > 0) {
                light->get(3).set(blue);  // 2h LED
              }
            }
          }
          
          // Filter life indicator LEDs (green -> yellow -> red gradient)
          // LED 1 = Filter (1200h life), LED 2 = Prefilter (300h life)
          float filter_pct = std::min(1.0f, id(filter_hours) / id(filter_life_hours));
          float prefilter_pct = std::min(1.0f, id(prefilter_hours) / id(prefilter_life_hours));
          
          // Calculate gradient: 0% = green, 50% = yellow, 100% = red
          auto pct_to_color = [dim](float pct) -> Color {
            uint8_t r, g;
            if (pct < 0.5f) {
              // Green to Yellow: increase red, keep green at max
              r = (uint8_t)(255 * (pct * 2.0f) * dim);
              g = (uint8_t)(255 * dim);
            } else {
              // Yellow to Red: keep red max, decrease green
              r = (uint8_t)(255 * dim);
              g = (uint8_t)(255 * (1.0f - (pct - 0.5f) * 2.0f) * dim);
            }
            return Color(r, g, 0, 0);
          };
          
          light->get(1).set(pct_to_color(filter_pct));
          light->get(2).set(pct_to_color(prefilter_pct));
          
          // Update Fan Speed LEDs (check factor)
          float factor = id(current_fan_speed_factor);
          if (factor > 0.9) { // Turbo 100%
             light->get(9).set(Color((uint8_t)(255*dim), 0, 0, 0));
          } else if (factor > 0.6) { // High 75%
             light->get(8).set(Color((uint8_t)(230*dim), (uint8_t)(135*dim), 0, 0));
          } else if (factor > 0.4) { // Mid 50%
             light->get(7).set(Color((uint8_t)(176*dim), (uint8_t)(200*dim), 0, 0));
          } else if (factor > 0.1) { // Low 25%
             light->get(6).set(Color(0, (uint8_t)(255*dim), 0, 0));
          }

          light->schedule_show();

  # Auto-dim check (every second)
  - interval: 1s
    then:
      - lambda: |-
          if (!id(leds_dimmed) && id(last_interaction_time) > 0) {
            uint32_t elapsed = millis() - id(last_interaction_time);
            if (elapsed > 5000) {
              id(leds_dimmed) = true;
            }
          }

  # Filter hour accumulation (every 10 minutes)
  - interval: 10min
    then:
      - lambda: |-
          float factor = id(current_fan_speed_factor);
          if (factor > 0) {
            // Add fractional hours: 10min = 1/6 hour * speed factor
            float hours_to_add = (1.0 / 6.0) * factor;
            id(filter_hours) = id(filter_hours) + hours_to_add;
            id(prefilter_hours) = id(prefilter_hours) + hours_to_add;
          }

sensor:
  - platform: template
    name: "Filter Hours"
    id: filter_hours_sensor
    unit_of_measurement: "h"
    accuracy_decimals: 3
    state_class: total_increasing
    lambda: |-
      return id(filter_hours);
    update_interval: 60s

  - platform: template
    name: "Prefilter Hours"
    id: prefilter_hours_sensor
    unit_of_measurement: "h"
    accuracy_decimals: 3
    state_class: total_increasing
    lambda: |-
      return id(prefilter_hours);
    update_interval: 60s
